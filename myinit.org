#+TITLE: My Emacs configuration
#+STARTUP: overview
#+DESCRIPTION: Loading emacs configuration using org-babel

* Introduction

This is my version of an configuration file for GNU Emacs.
You can find the latest version of this configuration at
https://github.com/handora/emacs.d

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Handora")
(setq user-mail-address "qcdsr970209@gmail.com")
#+END_SRC

* interface tweak
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (global-set-key (kbd "<f5>") 'revert-buffer)
  (setq org-src-fontify-natively t)
  (setq ring-bell-function 'ignore)
  (set-face-attribute 'default nil :height 170)

  ;; (use-package nyan-mode
  ;;   :ensure t
  ;;   :init (nyan-mode))

  (set-frame-font "Consolas 18")

  (use-package diminish
    :ensure t)

  ;; (use-package projectile
  ;;   :ensure t
  ;;   :config
  ;;   (add-hook 'prog-mode-hook 'projectile-mode))


  ;; (use-package powerline
  ;;   :ensure t
  ;;   :config
  ;;   (defvar mode-line-height 30 "A little bit taller, a little bit baller.")

  ;;   (defvar mode-line-bar          (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#909fab" nil)))
  ;;   (defvar mode-line-eldoc-bar    (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#B3EF00" nil)))
  ;;   (defvar mode-line-inactive-bar (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#9091AB" nil)))

  ;;   ;; Custom faces
  ;;   (defface mode-line-is-modified nil
  ;;     "Face for mode-line modified symbol")

  ;;   (defface mode-line-2 nil
  ;;     "The alternate color for mode-line text.")

  ;;   (defface mode-line-highlight nil
  ;;     "Face for bright segments of the mode-line.")

  ;;   (defface mode-line-count-face nil
  ;;     "Face for anzu/evil-substitute/evil-search number-of-matches display.")

  ;;   ;; Git/VCS segment faces
  ;;   (defface mode-line-vcs-info '((t (:inherit warning)))
  ;;     "")
  ;;   (defface mode-line-vcs-warning '((t (:inherit warning)))
  ;;     "")

  ;;   ;; Flycheck segment faces
  ;;   (defface doom-flycheck-error '((t (:inherit error)))
  ;;     "Face for flycheck error feedback in the modeline.")
  ;;   (defface doom-flycheck-warning '((t (:inherit warning)))
  ;;     "Face for flycheck warning feedback in the modeline.")


  ;;   (defun doom-ml-flycheck-count (state)
  ;;     "Return flycheck information for the given error type STATE."
  ;;     (when (flycheck-has-current-errors-p state)
  ;;       (if (eq 'running flycheck-last-status-change)
  ;;           "?"
  ;;         (cdr-safe (assq state (flycheck-count-errors flycheck-current-errors))))))

  ;;   (defun doom-fix-unicode (font &rest chars)
  ;;     "Display certain unicode characters in a specific font.
  ;;     e.g. (doom-fix-unicode \"DejaVu Sans\" ?⚠ ?★ ?λ)"
  ;;     (declare (indent 1))
  ;;     (mapc (lambda (x) (set-fontset-font
  ;;                        t (cons x x)
  ;;                        (cond ((fontp font)
  ;;                               font)
  ;;                              ((listp font)
  ;;                               (font-spec :family (car font) :size (nth 1 font)))
  ;;                              ((stringp font)
  ;;                               (font-spec :family font))
  ;;                              (t (error "FONT is an invalid type: %s" font)))))
  ;;           chars))

  ;;   ;; Make certain unicode glyphs bigger for the mode-line.
  ;;   ;; FIXME Replace with all-the-icons?
  ;;   (doom-fix-unicode '("DejaVu Sans Mono" 15) ?✱) ;; modified symbol
  ;;   (let ((font "DejaVu Sans Mono for Powerline")) ;;
  ;;     (doom-fix-unicode (list font 12) ?)  ;; git symbol
  ;;     (doom-fix-unicode (list font 16) ?∄)  ;; non-existent-file symbol
  ;;     (doom-fix-unicode (list font 15) ?)) ;; read-only symbol

  ;;   ;; So the mode-line can keep track of "the current window"
  ;;   (defvar mode-line-selected-window nil)
  ;;   (defun doom|set-selected-window (&rest _)
  ;;     (let ((window (frame-selected-window)))
  ;;       (when (and (windowp window)
  ;;                  (not (minibuffer-window-active-p window)))
  ;;         (setq mode-line-selected-window window))))
  ;;   (add-hook 'window-configuration-change-hook #'doom|set-selected-window)
  ;;   (add-hook 'focus-in-hook #'doom|set-selected-window)
  ;;   (advice-add 'select-window :after 'doom|set-selected-window)
  ;;   (advice-add 'select-frame  :after 'doom|set-selected-window)

  ;;   (defun doom/project-root (&optional strict-p)
  ;;     "Get the path to the root of your project."
  ;;     (let (projectile-require-project-root strict-p)
  ;;       (projectile-project-root)))

  ;;   (defun *buffer-path ()
  ;;     "Displays the buffer's full path relative to the project root (includes the
  ;;     project root). Excludes the file basename. See `*buffer-name' for that."
  ;;     (when buffer-file-name
  ;;       (propertize
  ;;        (f-dirname
  ;;         (let ((buffer-path (file-relative-name buffer-file-name (doom/project-root)))
  ;;               (max-length (truncate (/ (window-body-width) 1.75))))
  ;;           (concat (projectile-project-name) "/"
  ;;                   (if (> (length buffer-path) max-length)
  ;;                       (let ((path (reverse (split-string buffer-path "/" t)))
  ;;                             (output ""))
  ;;                         (when (and path (equal "" (car path)))
  ;;                           (setq path (cdr path)))
  ;;                         (while (and path (<= (length output) (- max-length 4)))
  ;;                           (setq output (concat (car path) "/" output))
  ;;                           (setq path (cdr path)))
  ;;                         (when path
  ;;                           (setq output (concat "../" output)))
  ;;                         (when (string-suffix-p "/" output)
  ;;                           (setq output (substring output 0 -1)))
  ;;                         output)
  ;;                     buffer-path))))
  ;;        'face (if active 'mode-line-2))))

  ;;   (defun *buffer-name ()
  ;;     "The buffer's base name or id."
  ;;     ;; FIXME Don't show uniquify tags
  ;;     (s-trim-left (format-mode-line "%b")))

  ;;   (defun *buffer-pwd ()
  ;;     "Displays `default-directory', for special buffers like the scratch buffer."
  ;;     (propertize
  ;;      (concat "[" (abbreviate-file-name default-directory) "]")
  ;;      'face 'mode-line-2))

  ;;   (defun *buffer-state ()
  ;;     "Displays symbols representing the buffer's state (non-existent/modified/read-only)"
  ;;     (when buffer-file-name
  ;;       (propertize
  ;;        (concat (if (not (file-exists-p buffer-file-name))
  ;;                    "∄"
  ;;                  (if (buffer-modified-p) "✱"))
  ;;                (if buffer-read-only ""))
  ;;        'face 'mode-line-is-modified)))

  ;;   (defun *buffer-encoding-abbrev ()
  ;;     "The line ending convention used in the buffer."
  ;;     (if (memq buffer-file-coding-system '(utf-8 utf-8-unix))
  ;;         ""
  ;;       (symbol-name buffer-file-coding-system)))

  ;;   (defun *major-mode ()
  ;;     "The major mode, including process, environment and text-scale info."
  ;;     (concat (format-mode-line mode-name)
  ;;             (if (stringp mode-line-process) mode-line-process)
  ;;             (and (featurep 'face-remap)
  ;;                  (/= text-scale-mode-amount 0)
  ;;                  (format " (%+d)" text-scale-mode-amount))))

  ;;   (defun *vc ()
  ;;     "Displays the current branch, colored based on its state."
  ;;     (when vc-mode
  ;;       (let ((backend (concat " " (substring vc-mode (+ 2 (length (symbol-name (vc-backend buffer-file-name)))))))
  ;;             (face (let ((state (vc-state buffer-file-name)))
  ;;                     (cond ((memq state '(edited added))
  ;;                            'mode-line-vcs-info)
  ;;                           ((memq state '(removed needs-merge needs-update conflict removed unregistered))
  ;;                            'mode-line-vcs-warning)))))
  ;;         (if active
  ;;             (propertize backend 'face face)
  ;;           backend))))

  ;;   (defvar-local doom--flycheck-err-cache nil "")
  ;;   (defvar-local doom--flycheck-cache nil "")
  ;;   (defun *flycheck ()
  ;;     "Persistent and cached flycheck indicators in the mode-line."
  ;;     (when (and (featurep 'flycheck)
  ;;                flycheck-mode
  ;;                (or flycheck-current-errors
  ;;                    (eq 'running flycheck-last-status-change)))
  ;;       (or (and (or (eq doom--flycheck-err-cache doom--flycheck-cache)
  ;;                    (memq flycheck-last-status-change '(running not-checked)))
  ;;                doom--flycheck-cache)
  ;;           (and (setq doom--flycheck-err-cache flycheck-current-errors)
  ;;                (setq doom--flycheck-cache
  ;;                      (let ((fe (doom-ml-flycheck-count 'error))
  ;;                            (fw (doom-ml-flycheck-count 'warning)))
  ;;                        (concat
  ;;                         (if fe (propertize (format " •%d " fe)
  ;;                                            'face (if active
  ;;                                                      'doom-flycheck-error
  ;;                                                    'mode-line)))
  ;;                         (if fw (propertize (format " •%d " fw)
  ;;                                            'face (if active
  ;;                                                      'doom-flycheck-warning
  ;;                                                    'mode-line))))))))))

  ;;   (defun *buffer-position ()
  ;;     "A more vim-like buffer position."
  ;;     (let ((start (window-start))
  ;;           (end (window-end))
  ;;           (pend (point-max)))
  ;;       (if (and (= start 1)
  ;;                (= end pend))
  ;;           ":All"
  ;;         (cond ((= start 1) ":Top")
  ;;               ((= end pend) ":Bot")
  ;;               (t (format ":%d%%%%" (/ end 0.01 pend)))))))

  ;;   (defun my-mode-line (&optional id)
  ;;     `(:eval
  ;;       (let* ((active (eq (selected-window) mode-line-selected-window))
  ;;              (lhs (list (propertize " " 'display (if active mode-line-bar mode-line-inactive-bar))
  ;;                         (*flycheck)
  ;;                         " "
  ;;                         (*buffer-path)
  ;;                         (*buffer-name)
  ;;                         " "
  ;;                         (*buffer-state)
  ;;                         ,(if (eq id 'scratch) '(*buffer-pwd))))
  ;;              (rhs (list (*buffer-encoding-abbrev) "  "
  ;;                         (*vc)
  ;;                         ;;                          " "
  ;;                         ;;                          (when persp-curr persp-modestring)
  ;;                         " " (*major-mode) "  "
  ;;                         (propertize
  ;;                          (concat "(%l,%c) " (*buffer-position))
  ;;                          'face (if active 'mode-line-2))))
  ;;              (middle (propertize
  ;;                       " " 'display `((space :align-to (- (+ right right-fringe right-margin)
  ;;                                                          ,(1+ (string-width (format-mode-line rhs)))))))))
  ;;         (list lhs middle rhs))))

  ;;   (setq-default mode-line-format (my-mode-line)))
#+END_SRC
* ido
#+BEGIN_SRC emacs-lisp
(setq ido-enable-flex-matching t)
(setq ido-everywhere t)
(ido-mode 1)

(defalias 'list-buffers 'ibuffer-other-window)
#+END_SRC

* try
#+BEGIN_SRC emacs-lisp
(use-package try
	:ensure t)
#+END_SRC
  
* which key
  Brings up some help
  #+BEGIN_SRC emacs-lisp
  (use-package which-key
	:ensure t 
	:config
	(which-key-mode))
  #+END_SRC

* Ace windows
  For easy window switching
  #+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :init
    (progn
      (global-set-key [remap other-window] 'ace-window)
      ))
  #+END_SRC

* Swiper / Ivy / Counsel
  Swiper gives us a really efficient incremental search with regular expressions
  and Ivy / Counsel replace a lot of ido or helms completion functionality
  #+BEGIN_SRC emacs-lisp
    (use-package counsel
      :ensure t
      :bind
      (("M-x" . counsel-M-x)
       ("M-y" . counsel-yank-pop)
       :map ivy-minibuffer-map
       ("M-y" . ivy-next-line)))
     
    (use-package ivy
      :ensure t
      :diminish (ivy-mode)
      :bind (("C-x b" . ivy-switch-buffer))
      :config
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq ivy-count-format "%d/%d ")
      (setq ivy-display-style 'fancy))

    (use-package swiper
      :ensure t
      :bind*
      (("C-s" . swiper)
       ("C-c C-r" . ivy-resume)
       ("C-x C-f" . counsel-find-file)
       ("C-c h f" . counsel-describe-function)
       ("C-c h v" . counsel-describe-variable)
       ("C-c i u" . counsel-unicode-char)
       ("M-i" . counsel-imenu)
       ("C-c g" . counsel-git)
       ("C-c j" . counsel-git-grep)
       ("C-c k" . counsel-ag)
       ("C-c l" . scounsel-locate))
      :config
      (progn
        (ivy-mode 1)
        (setq ivy-use-virtual-buffers t)
        (setq ivy-display-style 'fancy)
                                            ;(global-set-key "\C-s" 'swiper)
                                            ;(global-set-key (kbd "C-c C-r") 'ivy-resume)
                                            ;(global-set-key (kbd "<f6>") 'ivy-resume)
                                            ;(global-set-key (kbd "M-x") 'counsel-M-x)
                                            ;(global-set-key (kbd "C-x C-f") 'counsel-find-file)
                                            ;(global-set-key (kbd "<f1> f") 'counsel-describe-function)
                                            ;(global-set-key (kbd "<f1> v") 'counsel-describe-variable)
                                            ;(global-set-key (kbd "<f1> l") 'counsel-load-library)
                                            ;(global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
                                            ;(global-set-key (kbd "<f2> u") 'counsel-unicode-char)
                                            ;(global-set-key (kbd "C-c g") 'counsel-git)
                                            ;(global-set-key (kbd "C-c j") 'counsel-git-grep)
                                            ;(global-set-key (kbd "C-c k") 'counsel-ag)
                                            ;(global-set-key (kbd "C-x l") 'counsel-locate)
                                            ;(global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
        (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
        ))

    (use-package ivy-hydra
      :ensure t)
  #+END_SRC

* Avy - navigate by searching for a letter on the screen and jumping to it
  See https://github.com/abo-abo/avy for more info
  #+BEGIN_SRC emacs-lisp
  (use-package avy
  :ensure t
  :bind ("M-s" . avy-goto-word-1)) ;; changed from char as per jcs
  #+END_SRC

* Autocomplete
  #+BEGIN_SRC emacs-lisp
        ; (use-package auto-complete
        ; :ensure t
        ; :init
        ; (progn
        ;   (ac-config-default)
        ;   (global-auto-complete-mode t)
        ;   ))

        (use-package company
          :ensure t
          :init
            (global-company-mode))

        (setq company-idle-delay t)
  #+END_SRC

* Themes and modeline
  #+BEGIN_SRC emacs-lisp
    (use-package color-theme
      :ensure t)
    (use-package zenburn-theme
      :ensure t)

    ;; (use-package smart-mode-line
    ;;   :ensure t
    ;;   :config
    ;;   (sml/setup))

    (use-package zerodark-theme
      :ensure t)
    (use-package all-the-icons)
    (load-theme 'zerodark t)
    (zerodark-setup-modeline-format)
    (load-theme 'zenburn t)
  #+END_SRC 

* Reveal.js
  #+BEGIN_SRC emacs-lisp
    (use-package ox-reveal
    :ensure ox-reveal)

    (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
    (setq org-reveal-mathjax t)

    ;; (use-package htmlize
    ;; :ensure t)

    (load-file ".emacs.d/emacs-htmlize/htmlize.el")

    (require 'htmlize)
  #+END_SRC

* Flycheck
  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :init
      (global-flycheck-mode t))

  #+END_SRC
  
* Python
  #+BEGIN_SRC emacs-lisp
    (setq py-python-command "python")
    (setq python-shell-interpreter "python")
    (setq python-indent-offset 4)

    (defun my/python-mode-hook ()
      (add-to-list 'company-backends 'company-jedi))

    (use-package company-jedi
      :ensure t
      :init
      (add-hook 'python-mode-hook 'my/python-mode-hook))
    (use-package elpy
      :ensure t
      :config 
      (elpy-enable))
    (use-package virtualenvwrapper
      :ensure t
      :config
      (venv-initialize-interactive-shells)
      (venv-initialize-eshell))
  #+END_SRC

* Yasnippet
  #+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :init
      (yas-global-mode 1))

    ;; the official collection of snippets for yasnippet
    (use-package yasnippet-snippets
      :ensure t)  

  #+END_SRC

* Undo Tree
  #+BEGIN_SRC emacs-lisp
    (use-package undo-tree
      :ensure t
      :init
      (global-undo-tree-mode))
  #+END_SRC
* Misc packages
  #+BEGIN_SRC emacs-lisp

  ; Highlights the current cursor line
  (global-hl-line-mode t)

  ; flashes the cursor's line when you scroll
  (use-package beacon
    :ensure t
    :config
    (beacon-mode 1)
    ; (setq beacon-color "#666600")
    )

  ; deletes all the whitespace when you hit backspace or delete
  (use-package hungry-delete
    :ensure t
    :config
    (global-hungry-delete-mode))

  ; expand the marked region in semantic increments (negative prefix to reduce region)
  (use-package expand-region
    :ensure t
    :config 
    (global-set-key (kbd "C-=") 'er/expand-region)) 

  ; aggresive-indent
  (use-package aggressive-indent
    :ensure t
    :config
    (global-aggressive-indent-mode 1))
  

  (setq save-interprogram-paste-before-kill t)
  #+END_SRC

* iedit and narrow / widen dwim
  #+BEGIN_SRC emacs-lisp
    ; mark and edit all copies of the marked region simultaniously. 
    (use-package iedit
      :ensure t)

  ; if you're windened, narrow to the region, if you're narrowed, widen
  ; bound to C-x n
  (defun narrow-or-widen-dwim (p)
  "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.
  
  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
  ((region-active-p)
  (narrow-to-region (region-beginning) (region-end)))
  ((derived-mode-p 'org-mode)
  ;; `org-edit-src-code' is not a real narrowing command.
  ;; Remove this first conditional if you don't want it.
  (cond ((ignore-errors (org-edit-src-code))
  (delete-other-windows))
  ((org-at-block-p)
  (org-narrow-to-block))
  (t (org-narrow-to-subtree))))
  (t (narrow-to-defun))))
  
  ;; (define-key endless/toggle-map "n" #'narrow-or-widen-dwim)
  ;; This line actually replaces Emacs' entire narrowing keymap, that's
  ;; how much I like this command. Only copy it if that's what you want.
  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)
  
  #+END_SRC

* Load other files
   #+BEGIN_SRC emacs-lisp
     (defun load-if-exists (f)
       "load the elisp file only if it exists and is readable"
       (if (file-readable-p f)
           (load-file f)))
   #+END_SRC

* Web Mode
#+BEGIN_SRC emacs-lisp
    (use-package web-mode
      :ensure t
      :config
	   (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
	   (add-to-list 'auto-mode-alist '("\\.vue?\\'" . web-mode))
	   (setq web-mode-engines-alist
		 '(("django"    . "\\.html\\'")))
	   (setq web-mode-ac-sources-alist
	   '(("css" . (ac-source-css-property))
	   ("vue" . (ac-source-words-in-buffer ac-source-abbrev))
           ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
  (setq web-mode-enable-auto-closing t))
  (setq web-mode-enable-auto-quoting t) ; this fixes the quote problem I mentioned
  (defun my-web-mode-hook ()
    "Hooks for Web mode."
    (setq web-mode-markup-indent-offset 2)
  )
  (add-hook 'web-mode-hook  'my-web-mode-hook)

#+END_SRC
* Org mode
  #+BEGIN_SRC emacs-lisp
    (setenv "BROWSER" "google-chrome-stable")

    ;; (use-package org-bullets
    ;;   :ensure t
    ;;   :config
    ;;   (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
    (setq org-startup-indented t
          org-hide-leading-stars t)

    (custom-set-variables
     '(org-directory "~/Dropbox/orgfiles")
     '(org-default-notes-file (concat org-directory "/notes.org"))
     '(org-export-html-postamble nil)
     '(org-hide-leading-stars t)
     '(org-startup-folded (quote overview))
     '(org-startup-indented t)
     )

    (setq org-file-apps
          (append '(
                    ("\\.pdf\\'" . "evince %s")
                    ) org-file-apps ))

    (global-set-key "\C-ca" 'org-agenda)

    (setq org-agenda-custom-commands
          '(("c" "Simple agenda view"
             ((agenda "")
              (alltodo "")))))

    ;; use for auto-complete
    ;; (use-package org-ac
    ;;   :ensure t
    ;;   :init (progn
    ;;        (require 'org-ac)
    ;;        (org-ac/config-default)
    ;;        ))

    (global-set-key (kbd "C-c c") 'org-capture)

    (setq org-agenda-files (list "~/Dropbox/orgfiles/gcal.org"
                                 "~/Dropbox/orgfiles/i.org"
                                 "~/Dropbox/orgfiles/schedule.org"
                                 "~/Dropbox/handora/life.org"))

    (setq org-capture-templates
          '(("a" "Appointment" entry (file  "~/Dropbox/orgfiles/gcal.org" )
             "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")
            ("l" "Link" entry (file+headline "~/Dropbox/orgfiles/links.org" "Links")
             "* %? %^L %^g \n%T" :prepend t)
            ("b" "Blog idea" entry (file+headline "~/Dropbox/orgfiles/i.org" "Blog Topics:")
             "* %?\n%T" :prepend t)
            ("t" "To Do Item" entry (file+headline "~/Dropbox/orgfiles/i.org" "To Do")
             "* TODO %?\n%u" :prepend t)
            ("m" "Mail To Do" entry (file+headline "~/Dropbox/orgfiles/i.org" "To Do")
             "* TODO %a\n %?" :prepend t)
            ("g" "GMail To Do" entry (file+headline "~/Dropbox/orgfiles/i.org" "To Do")
             "* TODO %^L\n %?" :prepend t)
            ("n" "Note" entry (file+headline "~/Dropbox/orgfiles/i.org" "Note space")
             "* %?\n%u" :prepend t)
            ))
    ;; (setq org-capture-templates
    ;;                  '(("a" "Appointment" entry (file  "~/Dropbox/orgfiles/gcal.org" )
    ;;                           "* TODO %?\n:PROPERTIES:\nDEADLINE: %^T \n\n:END:\n %i\n")
    ;;                          ("l" "Link" entry (file+headline "~/Dropbox/orgfiles/links.org" "Links")
    ;;                           "* %? %^L %^g \n%T" :prepend t)
    ;;                          ("b" "Blog idea" entry (file+headline "~/Dropbox/orgfiles/i.org" "Blog Topics:")
    ;;                           "* %?\n%T" :prepend t)
    ;;                          ("t" "To Do Item" entry (file+headline "~/Dropbox/orgfiles/i.org" "To Do")
    ;;                           "* TODO %?\n%u" :prepend t)
    ;;                          ("n" "Note" entry (file+headline "~/Dropbox/orgfiles/i.org" "Note space")
    ;;                           "* %?\n%u" :prepend t)

    ;;                          ("j" "Journal" entry (file+datetree "~/Dropbox/journal.org")
    ;;                           "* %?\nEntered on %U\n  %i\n  %a")
    ;;                                ("s" "Screencast" entry (file "~/Dropbox/orgfiles/screencastnotes.org")
    ;;                                "* %?\n%i\n")))


    (defadvice org-capture-finalize
        (after delete-capture-frame activate)  
      "Advise capture-finalize to close the frame"  
      (if (equal "capture" (frame-parameter nil 'name))  
          (delete-frame)))

    (defadvice org-capture-destroy 
        (after delete-capture-frame activate)  
      "Advise capture-destroy to close the frame"  
      (if (equal "capture" (frame-parameter nil 'name))  
          (delete-frame)))  

    (use-package noflet
      :ensure t )
    (defun make-capture-frame ()
      "Create a new frame and run org-capture."
      (interactive)
      (make-frame '((name . "capture")))
      (select-frame-by-name "capture")
      (delete-other-windows)
      (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
        (org-capture)))

    (require 'ox-beamer)

                                            ; for inserting inactive dates
    (define-key org-mode-map (kbd "C-c >") (lambda () (interactive (org-time-stamp-inactive))))

    ;; for personal secret
    (use-package org-gcal
      :ensure t
      :config
      (load-file "/home/handora/.emacs.secret"))

    (add-hook 'org-agenda-mode-hook (lambda () (org-gcal-fetch) ))
    ;; (add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-sync) )) 

    (use-package calfw-org
      :ensure t)

    (use-package calfw-ical
      :ensure t)

    (use-package calfw
      :ensure t;TODO: 
      :config
      (require 'calfw) 
      (require 'calfw-org)
      (setq cfw:org-overwrite-default-keybinding t)
      (require 'calfw-ical)

      (defun mycalendar ()
        (interactive)
        (cfw:open-calendar-buffer
         :contents-sources
         (list
          ;; (cfw:org-create-source "Green")  ; orgmode source
          (cfw:ical-create-source "gcal" "https://somecalnedaraddress" "IndianRed") ; devorah calender
          (cfw:ical-create-source "gcal" "https://anothercalendaraddress" "IndianRed") ; google calendar ICS
          ))) 
      (setq cfw:org-overwrite-default-keybinding t))

    (use-package calfw-gcal
      :ensure t
      :config
      (require 'calfw-gcal))

    '(org-log-into-drawer t)
  #+END_SRC
* Stuff to refile as I do more Screencasts
#+BEGIN_SRC emacs-lisp

  (setq user-full-name "Qian Chen"
                          user-mail-address "qcdsr970209@gmail.com")
  ;;--------------------------------------------------------------------------


  ;; (global-set-key (kbd "\e\ei")
  ;;                 (lambda () (interactive) (find-file "~/Dropbox/orgfiles/i.org")))

  ;; (global-set-key (kbd "\e\el")
  ;;                 (lambda () (interactive) (find-file "~/Dropbox/orgfiles/links.org")))

  (global-set-key (kbd "\e\ec")
                  (lambda () (interactive) (find-file "~/.emacs.d/myinit.org")))
#+END_SRC
		  
* c++
#+BEGIN_SRC emacs-lisp
  (setq
   c-default-style "k&r" 
   c-basic-offset 2)

  (add-hook 'c++-mode-hook (lambda () (setq flycheck-gcc-language-standard "c++11")))
  (add-hook 'c++-mode-hook (lambda () (setq flycheck-clang-language-standard "c++11")))

  (use-package irony
    :ensure t
    :config
    (progn
      (add-hook 'c++-mode-hook 'irony-mode)
      (add-hook 'c-mode-hook 'irony-mode)
      (defun my-irony-mode-hook ()
        (define-key irony-mode-map
          [remap completion-at-point] 'counsel-irony)
        (define-key irony-mode-map
          [remap complete-symbol] 'counsel-irony))
      (add-hook 'irony-mode-hook 'my-irony-mode-hook)

      ;; Use compilation database first, clang_complete as fallback.
      (setq-default irony-cdb-compilation-databases '(irony-cdb-libclang
                                                      irony-cdb-clang-complete))

      (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
      ))

  ;; I use irony with company to get code completion.
  (use-package company-irony
    :ensure t
    :config
    (progn
      (eval-after-load 'company '(add-to-list 'company-backends 'company-irony))))

  ;; I use irony with flycheck to get real-time syntax checking.
  (use-package flycheck-irony
    :ensure t
    :config
    (progn
      (eval-after-load 'flycheck '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))))

  ;; Eldoc shows argument list of the function you are currently writing in the echo area.
  (use-package irony-eldoc
    :ensure t
    :config
    (progn
      (add-hook 'irony-mode-hook #'irony-eldoc)))

  (use-package rtags
    :ensure t
    :config
    (progn
      (defun ciao-goto-symbol ()
        (interactive)
        (deactivate-mark)
        (ring-insert find-tag-marker-ring (point-marker))
        (or (and (require 'rtags nil t)
                 (rtags-find-symbol-at-point))
            (and (require 'semantic/ia)
                 (condition-case nil
                     (semantic-ia-fast-jump (point))
                   (error nil)))))
      (define-key c++-mode-map (kbd "M-.") 'ciao-goto-symbol)
      (define-key c++-mode-map (kbd "M-,") 'pop-tag-mark)))

  (use-package company-irony-c-headers
    :ensure t
    :config
    (eval-after-load 'company
      '(add-to-list
        'company-backends '(company-irony-c-headers company-irony))))

  (use-package cmake-ide
    :ensure t
    :defer t
    :init (progn
            (add-hook 'c++-mode-hook (lambda () (cmake-ide-setup)))
            (add-hook 'c-mode-hook (lambda () (cmake-ide-setup)))
            ))

  (use-package cmake-mode
    :ensure t
    :mode (
           ("CMakeLists\\.txt\\'" . cmake-mode)
           ("\\.cmake\\'" . cmake-mode)
           ))

(defconst my-cc-style
  '("cc-mode"
    (c-offsets-alist . ((innamespace . [0])))))

(c-add-style "my-cc-mode" my-cc-style)
#+END_SRC
* smartparens
#+BEGIN_SRC emacs-lisp 
(use-package smartparens
  :ensure t
  :config
  (use-package smartparens-config)
  (use-package smartparens-html)
  (use-package smartparens-python)
  (use-package smartparens-latex)
  (smartparens-global-mode t)
  (show-smartparens-global-mode t)
  :bind
  ( ("C-<down>" . sp-down-sexp)
   ("C-<up>"   . sp-up-sexp)
   ("M-<down>" . sp-backward-down-sexp)
   ("M-<up>"   . sp-backward-up-sexp)
  ("C-M-a" . sp-beginning-of-sexp)
   ("C-M-e" . sp-end-of-sexp)



   ("C-M-f" . sp-forward-sexp)
   ("C-M-b" . sp-backward-sexp)

   ("C-M-n" . sp-next-sexp)
   ("C-M-p" . sp-previous-sexp)

   ("C-S-f" . sp-forward-symbol)
   ("C-S-b" . sp-backward-symbol)

   ("C-<right>" . sp-forward-slurp-sexp)
   ("M-<right>" . sp-forward-barf-sexp)
   ("C-<left>"  . sp-backward-slurp-sexp)
   ("M-<left>"  . sp-backward-barf-sexp)

   ("C-M-t" . sp-transpose-sexp)
   ("C-M-k" . sp-kill-sexp)
   ("C-k"   . sp-kill-hybrid-sexp)
   ("M-k"   . sp-backward-kill-sexp)
   ("C-M-w" . sp-copy-sexp)

   ("C-M-d" . delete-sexp)

   ("M-<backspace>" . backward-kill-word)
   ("C-<backspace>" . sp-backward-kill-word)
   ([remap sp-backward-kill-word] . backward-kill-word)

   ("M-[" . sp-backward-unwrap-sexp)
   ("M-]" . sp-unwrap-sexp)

   ("C-x C-t" . sp-transpose-hybrid-sexp)

   ("C-c ("  . wrap-with-parens)
   ("C-c ["  . wrap-with-brackets)
   ("C-c {"  . wrap-with-braces)
   ("C-c '"  . wrap-with-single-quotes)
   ("C-c \"" . wrap-with-double-quotes)
   ("C-c _"  . wrap-with-underscores)
  ("C-c `"  . wrap-with-back-quotes)
  ))
#+END_SRC

* Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
    :ensure t
    :config
    (projectile-global-mode)
  (setq projectile-completion-system 'ivy))

(use-package counsel-projectile
    :ensure t
    :config
    (counsel-projectile-mode))
#+END_SRC

* Dumb jump
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :bind (("M-g o" . dumb-jump-go-other-window)
         ("M-g j" . dumb-jump-go)
         ("M-g x" . dumb-jump-go-prefer-external)
         ("M-g z" . dumb-jump-go-prefer-external-other-window))
  :config 
  ;; (setq dumb-jump-selector 'ivy) ;; (setq dumb-jump-selector 'helm)
:init
(dumb-jump-mode)
  :ensure
)
#+END_SRC
* IBUFFER
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (setq ibuffer-saved-filter-groups
	(quote (("default"
		 ("dired" (mode . dired-mode))
		 ("org" (name . "^.*org$"))
	       
		 ("web" (or (mode . web-mode) (mode . js2-mode)))
		 ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
		 ("mu4e" (or

                 (mode . mu4e-compose-mode)
                 (name . "\*mu4e\*")
                 ))
		 ("programming" (or
				 (mode . python-mode)
				 (mode . c++-mode)))
		 ("emacs" (or
			   (name . "^\\*scratch\\*$")
			   (name . "^\\*Messages\\*$")))
		 ))))
  (add-hook 'ibuffer-mode-hook
	    (lambda ()
	      (ibuffer-auto-mode 1)
	      (ibuffer-switch-to-saved-filter-groups "default")))

  ;; don't show these
  ;; (add-to-list 'ibuffer-never-show-predicates "zowie")
  ;; Don't show filter groups if there are no buffers in that group
  (setq ibuffer-show-empty-filter-groups nil)

  ;; Don't ask for confirmation to delete marked buffers
  (setq ibuffer-expert t)

#+END_SRC
* Emmet mode
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
:ensure t
:config
(add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes
(add-hook 'web-mode-hook 'emmet-mode) ;; Auto-start on any markup modes
(add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.
)
#+END_SRC
* Personal configureation
Mousewheel scrolling can be quite annoying, lets fix it to scroll smoothly.
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
(setq mouse-wheel-progressive-speed nil)
#+END_SRC
* Treemacs
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t
    :defer t
    :config
    (progn

      (setq treemacs-follow-after-init          t
            treemacs-width                      35
            treemacs-indentation                2
            treemacs-git-integration            t
            treemacs-collapse-dirs              3
            treemacs-silent-refresh             nil
            treemacs-change-root-without-asking nil
            treemacs-sorting                    'alphabetic-desc
            treemacs-show-hidden-files          t
            treemacs-never-persist              nil
            treemacs-is-never-other-window      nil
            treemacs-goto-tag-strategy          'refetch-index)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t))
    :bind
    (:map global-map
          ([f8]        . treemacs-toggle)
          ([f9]        . treemacs-projectile-toggle)
          ("<C-M-tab>" . treemacs-toggle)
          ("M-0"       . treemacs-select-window)
          ("C-c 1"     . treemacs-delete-other-windows)
        ))
  (use-package treemacs-projectile
    :defer t
    :ensure t
    :config
    (setq treemacs-header-function #'treemacs-projectile-create-header)
)

#+END_SRC
* Dired
#+BEGIN_SRC emacs-lisp
  ; wiki melpa problem
  ;(use-package dired+
  ;  :ensure t
  ;  :config (require 'dired+))
                                          ;  )

  (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
  (require 'dired+)

#+END_SRC
* Markdown mode
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t)
#+END_SRC
* Git
#+BEGIN_SRC emacs-lisp
    (use-package magit
      :ensure t
      :bind (("C-c m" . magit-status)))

    (use-package magit-gitflow
      :ensure t
      :config
      (add-hook 'magit-mode-hook 'turn-on-magit-gitflow)) 

    (use-package git-gutter
      :ensure t
      :init
      (global-git-gutter-mode +1)
      :config
      (set-face-background 'git-gutter:modified "#b58900")
      (set-face-background 'git-gutter:added "#859900")
      (set-face-background 'git-gutter:deleted "#dc322f")

      (set-face-foreground 'git-gutter:modified "none")
      (set-face-foreground 'git-gutter:added "none")
      (set-face-foreground 'git-gutter:deleted "none")
      (setq git-gutter:modified-sign " ~")
      (setq git-gutter:added-sign " +")
      (setq git-gutter:deleted-sign " -")
      (setq git-gutter:window-width 3))

  (defun qc/git-gutter-recover()
    (interactive)
    (set-face-background 'git-gutter:modified "#b58900")
    (set-face-background 'git-gutter:added "#859900")
    (set-face-background 'git-gutter:deleted "#dc322f")

    (set-face-foreground 'git-gutter:modified "none")
    (set-face-foreground 'git-gutter:added "none")
    (set-face-foreground 'git-gutter:deleted "none")
    (setq git-gutter:modified-sign " ~")
    (setq git-gutter:added-sign " +")
    (setq git-gutter:deleted-sign " -")
    (setq git-gutter:window-width 3))

  (use-package git-timemachine
      :ensure t
      )

    (defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
                                          :hint nil)
      "
      Git gutter:
        _j_: next hunk        _s_tage hunk     _q_uit
        _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
        ^ ^                   _p_opup hunk
        _h_: first hunk
        _l_: last hunk        set start _R_evision
      "
      ("j" git-gutter:next-hunk)
      ("k" git-gutter:previous-hunk)
      ("h" (progn (goto-char (point-min))
                  (git-gutter:next-hunk 1)))
      ("l" (progn (goto-char (point-min))
                  (git-gutter:previous-hunk 1)))
      ("s" git-gutter:stage-hunk)
      ("r" git-gutter:revert-hunk)
      ("p" git-gutter:popup-hunk)
      ("R" git-gutter:set-start-revision)
      ("q" nil :color blue)
      ("Q" (progn (git-gutter-mode -1)
                  ;; git-gutter-fringe doesn't seem to
                  ;; clear the markup right away
                  (sit-for 0.1)
                  (git-gutter:clear))
       :color blue))

    (global-set-key (kbd "M-g M-g") 'hydra-git-gutter/body)
#+END_SRC
* Code Folding
#+BEGIN_SRC emacs-lisp
  (use-package hideshow
    :ensure t
    :bind (("C->" . my-toggle-hideshow-all)
           ("C-<" . hs-hide-level)
           ("C-;" . hs-toggle-hiding))
    :config
    ;; Hide the comments too when you do a 'hs-hide-all'
    (setq hs-hide-comments nil)
    ;; Set whether isearch opens folded comments, code, or both
    ;; where x is code, comments, t (both), or nil (neither)
    (setq hs-isearch-open 'x)
    ;; Add more here


    (setq hs-set-up-overlay
          (defun my-display-code-line-counts (ov)
            (when (eq 'code (overlay-get ov 'hs))
              (overlay-put ov 'display
                           (propertize
                            (format " ... <%d>"
                                    (count-lines (overlay-start ov)
                                                 (overlay-end ov)))
                            'face 'font-lock-type-face)))))

    (defvar my-hs-hide nil "Current state of hideshow for toggling all.")
         ;;;###autoload
    (defun my-toggle-hideshow-all () "Toggle hideshow all."
           (interactive)
           (setq my-hs-hide (not my-hs-hide))
           (if my-hs-hide
               (hs-hide-all)
             (hs-show-all)))
;    (add-hook 'prog-mode-hook (lambda ()
;                                (hs-minor-mode 1)
;                                ))
    )
#+END_SRC

* Bookmarks
  Bookmarks are very useful for quickly jumping around files.
#+BEGIN_SRC emacs-lisp
  (use-package bm
    :ensure t
    :bind (("C-c =" . bm-toggle)
           ("C-c [" . bm-previous)
           ("C-c ]" . bm-next)))
#+END_SRC
* Rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook
              (lambda()
                (rainbow-delimiters-mode)
                ))) 
#+END_SRC
* Go
#+BEGIN_SRC emacs-lisp
  (require 'th-golang)

  (defun my-go-setup ()
    (setq tab-width 2)
    (go-guru-hl-identifier-mode))

  (add-hook 'go-mode-hook 'my-go-setup)

  (add-to-list 'yas-snippet-dirs "/home/handora/.emacs.d/yasnippet-go")

  (use-package go-playground
    :ensure t)

  (use-package go-guru
    :ensure t)

#+END_SRC
* Elfeed
#+BEGIN_SRC emacs-lisp
  (setq elfeed-db-directory "~/Dropbox/elfeed/elfeeddb")


  (defun elfeed-mark-all-as-read ()
    (interactive)
    (mark-whole-buffer)
    (elfeed-search-untag-all-unread))


  ;;functions to support syncing .elfeed between machines
  ;;makes sure elfeed reads index from disk before launching
  (defun bjm/elfeed-load-db-and-open ()
    "Wrapper to load the elfeed db from disk before opening"
    (interactive)
    (elfeed-db-load)
    (elfeed)
    (elfeed-search-update--force))

  ;;write to disk when quiting
  (defun bjm/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))

  (use-package elfeed
    :ensure t
    :bind (:map elfeed-search-mode-map
                ("q" . bjm/elfeed-save-db-and-bury)
                ("Q" . bjm/elfeed-save-db-and-bury)
                ("m" . elfeed-toggle-star)
                ("M" . elfeed-toggle-star)
                ("j" . mz/make-and-run-elfeed-hydra)
                ("J" . mz/make-and-run-elfeed-hydra)
                )
    :config
    (defalias 'elfeed-toggle-star
      (elfeed-expose #'elfeed-search-toggle-all 'star))
    )

  (use-package elfeed-goodies
    :ensure t
    :config
    (elfeed-goodies/setup))


  (use-package elfeed-org
    :ensure t
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/Dropbox/elfeed/elfeed.org")))

  (defun z/hasCap (s) ""
         (let ((case-fold-search nil))
           (string-match-p "[[:upper:]]" s)
           ))

  (defun z/get-hydra-option-key (s)
    "returns single upper case letter (converted to lower) or first"
    (interactive)
    (let ( (loc (z/hasCap s)))
      (if loc
          (downcase (substring s loc (+ loc 1)))
        (substring s 0 1)
        )))

  ;;  (active blogs cs eDucation emacs local misc sports star tech unread webcomics)
  (defun mz/make-elfeed-cats (tags)
    "Returns a list of lists. Each one is line for the hydra configuratio in the form
         (c function hint)"
    (interactive)
    (mapcar (lambda (tag)
              (let* (
                     (tagstring (symbol-name tag))
                     (c (z/get-hydra-option-key tagstring))
                     )
                (list c (append '(elfeed-search-set-filter) (list (format "@6-months-ago +%s" tagstring) ))tagstring  )))
            tags))

  (defmacro mz/make-elfeed-hydra ()
    `(defhydra mz/hydra-elfeed ()
       "filter"
       ,@(mz/make-elfeed-cats (elfeed-db-get-all-tags))
       ("*" (elfeed-search-set-filter "@6-months-ago +star") "Starred")
       ("M" elfeed-toggle-star "Mark")
       ("A" (elfeed-search-set-filter "@6-months-ago") "All")
       ("T" (elfeed-search-set-filter "@1-day-ago") "Today")
       ("Q" bjm/elfeed-save-db-and-bury "Quit Elfeed" :color blue)
       ("q" nil "quit" :color blue)
       ))

  (defun mz/make-and-run-elfeed-hydra ()
    ""
    (interactive)
    (mz/make-elfeed-hydra)
    (mz/hydra-elfeed/body))
#+END_SRC
* Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra 
    :ensure hydra
    :init 
    (global-set-key
    (kbd "C-x t")
            (defhydra toggle (:color blue)
              "toggle"
              ("a" abbrev-mode "abbrev")
              ("s" flyspell-mode "flyspell")
              ("d" toggle-debug-on-error "debug")
              ("c" fci-mode "fCi")
              ("f" auto-fill-mode "fill")
              ("t" toggle-truncate-lines "truncate")
              ("w" whitespace-mode "whitespace")
              ("q" nil "cancel")))
    (global-set-key
     (kbd "C-x j")
     (defhydra gotoline 
       ( :pre (linum-mode 1)
              :post (linum-mode -1))
       "goto"
       ("t" (lambda () (interactive)(move-to-window-line-top-bottom 0)) "top")
       ("b" (lambda () (interactive)(move-to-window-line-top-bottom -1)) "bottom")
       ("m" (lambda () (interactive)(move-to-window-line-top-bottom)) "middle")
       ("e" (lambda () (interactive)(end-of-buffer)) "end")
       ("c" recenter-top-bottom "recenter")
       ("n" next-line "down")
       ("p" (lambda () (interactive) (forward-line -1))  "up")
       ("g" goto-line "goto-line")
       ))
    (global-set-key
     (kbd "C-c t")
     (defhydra hydra-global-org (:color blue)
       "Org"
       ("t" org-timer-start "Start Timer")
       ("s" org-timer-stop "Stop Timer")
       ("r" org-timer-set-timer "Set Timer") ; This one requires you be in an orgmode doc, as it sets the timer for the header
       ("p" org-timer "Print Timer") ; output timer value to buffer
       ("w" (org-clock-in '(4)) "Clock-In") ; used with (org-clock-persistence-insinuate) (setq org-clock-persist t)
       ("o" org-clock-out "Clock-Out") ; you might also want (setq org-log-note-clock-out t)
       ("j" org-clock-goto "Clock Goto") ; global visit the clocked task
       ("c" org-capture "Capture") ; Don't forget to define the captures you want http://orgmode.org/manual/Capture.html
             ("l" (or )rg-capture-goto-last-stored "Last Capture"))

     ))
#+END_SRC
* Misc
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "google-chrome-stable")
#+END_SRC
* Personal key-binding
#+BEGIN_SRC emacs-lisp
  (defun org-agenda-show-agenda-and-todo (&optional arg)
    (interactive "P")
    (org-agenda arg "c")
    (org-agenda-fortnight-view))

  ;; set up my own map
  (define-prefix-command 'z-map)
  (global-set-key (kbd "C-c z") 'z-map)
  (define-key z-map (kbd "c") 'multiple-cursors-hydra/body)
  (define-key z-map (kbd "m") 'mu4e)
  (define-key z-map (kbd "e") 'bjm/elfeed-load-db-and-open)
  (define-key z-map (kbd "1") 'org-global-cycle)
  (define-key z-map (kbd "a") 'org-agenda-show-agenda-and-todo)
  (define-key z-map (kbd "g") 'counsel-ag)

  (define-key z-map (kbd "s") 'flyspell-correct-word-before-point)
  (define-key z-map (kbd "i") (lambda () (interactive) (find-file "~/Dropbox/orgfiles/i.org")))
  (define-key z-map (kbd "f") 'origami-toggle-node)
  (define-key z-map (kbd "w") 'z/swap-windows)

#+END_SRC
* Atomic Chrome 
#+BEGIN_SRC emacs-lisp
  (use-package atomic-chrome
    :ensure t
    :config (atomic-chrome-start-server))

  (setq atomic-chrome-buffer-open-style 'frame)
#+END_SRC
* Customize
* Music
#+BEGIN_SRC emacs-lisp
  (use-package simple-mpc
    :ensure t)
#+END_SRC
* Regex
#+BEGIN_SRC emacs-lisp
  (use-package pcre2el
    :ensure t
    :config 
    (pcre-mode)
    )
#+END_SRC

* Wgrep

#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :ensure t
    )

  (setq counsel-fzf-cmd "/home/handora/.fzf/bin/fzf -f %s")
#+END_SRC
* PDF
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t)
  (use-package org-pdfview
    :ensure t)
  (require 'pdf-tools)
  (require 'org-pdfview)
#+END_SRC
* latex
#+BEGIN_SRC emacs-lisp
  (load "auctex.el" nil t t)
  (load "preview-latex.el" nil t t)
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq TeX-save-query nil)
  (setq TeX-PDF-mode t)

  (defun flymake-get-tex-args (file-name)
    (list "pdflatex"
          (list "-file-line-error" "-draftmode" "-interaction=nonstopmode" file-name)))

  (add-hook 'LaTeX-mode-hook 'flymake-mode)

  (setq ispell-program-name "aspell") ; could be ispell as well, depending on your preferences
  (setq ispell-dictionary "english") ; this can obviously be set to any language your spell-checking program supports

  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-buffer)
#+END_SRC
* Scala
#+BEGIN_SRC emacs-lisp
  (use-package ensime
    :ensure t)

  (use-package scala-mode
    :ensure t)
#+END_SRC
* Protobuf
#+BEGIN_SRC emacs-lisp
  (defconst my-protobuf-style
    '((c-basic-offset . 2)
      (indent-tabs-mode . nil)))

  (use-package protobuf-mode
    :ensure t
    :config
    (add-hook 'protobuf-mode-hook
              (lambda () (c-add-style "my-style" my-protobuf-style t))))
#+END_SRC
* flex&bison
#+BEGIN_SRC emacs-lisp
  (use-package bison-mode
    :ensure t)
#+END_SRC
* hugo
#+BEGIN_SRC emacs-lisp
  (use-package ox-hugo
    :ensure t
    :after ox)

#+END_SRC
* Ocaml
#+BEGIN_SRC emacs-lisp
  (use-package tuareg 
    :ensure t
    :config
    (setq tuareg-match-patterns-aligned t))

  (let ((opam-share (ignore-errors (car (process-lines "opam" "config" "var" "share")))))
    (when (and opam-share (file-directory-p opam-share))
      (add-to-list 'load-path (expand-file-name "emacs/site-lisp" opam-share))
      (autoload 'merlin-mode "merlin" nil t nil)
      (add-hook 'tuareg-mode-hook 'merlin-mode t)
      (add-hook 'caml-mode-hook 'merlin-mode t)))

  (add-hook 'tuareg-mode-hook 'merlin-mode)

  ; Make company aware of merlin
  (with-eval-after-load 'company
    (add-to-list 'company-backends 'merlin-company-backend))
    ; Enable company on merlin managed buffers
  (add-hook 'merlin-mode-hook 'company-mode)

  (use-package flycheck-ocaml
    :ensure t)

  (with-eval-after-load 'merlin
    ;; Disable Merlin's own error checking
    (setq merlin-error-after-save nil)

    ;; Enable Flycheck checker
    (flycheck-ocaml-setup))

  (add-hook 'tuareg-mode-hook #'merlin-mode)
#+END_SRC
